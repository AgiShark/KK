@page "/"
@using System.IO;
@using Microsoft.Extensions.Logging
@inject KK_SaveLoadCompression.SaveLoadCompression slc;
@inject IJSRuntime JS;
@inject ILogger<Index> logger;
@inject BlazorDownloadFile.IBlazorDownloadFileService BlazorDownloadFileService;

<div class="text-center">
    <p class="lead">
        @if (loading && null == buffer) {
            <div class="lds-dual-ring"></div>
            <div>Please be patient...</div>
        }
        <EditForm Model="this" @bind-hidden="loading">
            <div class="d-flex justify-content-center">
                <label>
                    <a class="btn btn-lg btn-outline-secondary text-white" style="font-size: xx-large;cursor:pointer">Choose your Koikatu png</a>
                    <InputFile OnChange="@OnSelectedFile" accept="image/png" hidden></InputFile>
                </label>
            </div>
            <br />
            <label data-toggle="tooltip" title="Skip the compare can reduce the computing time on compressing, but please bear the risk."> <InputCheckbox @bind-Value="@doCompare"></InputCheckbox>Do Compare</label>
        </EditForm>
    </p>
    @if (null != buffer && buffer.Length > 0) {
        <hr />
        <img src="data:image;base64,@System.Convert.ToBase64String(buffer)" style="max-height:45vh" />
        <p class="lead">
            @if (compress) {
                @:Compression
            } else {
                @:Decompression
            } is completed in @(Convert.ToInt32(DateTime.UtcNow.AddHours(8).Subtract(new DateTime(1970, 1, 1)).TotalSeconds) - startTime) seconds.<br />
            Size from @($"{(Convert.ToDecimal(inputFileSize) / 1048576):n2} MB to {(Convert.ToDecimal(buffer.Length) / 1048576):n2} MB.")<br />
            It is now @($"{Convert.ToDecimal(buffer.Length) / inputFileSize:p3}") big.<br />

            @if (loading) {
                <div class="lds-dual-ring"></div>
                <div>Please be patient...</div>
            } else {
                <a @onclick="@DownloadFile" class="btn btn-lg btn-outline-secondary">Save</a>
            }
        </p>
    }
</div>

<div id="noticeBox">
    <h2 id="noticeTitle">!!Notice!!</h2>
    <div class="d-flex flex-column ">
        <div>
            <h4>Q: 你會如何使用我的存檔?</h4>
            <p>
                本工具使用<a href="https://docs.microsoft.com/zh-tw/aspnet/core/blazor/?view=aspnetcore-5.0#blazor-webassembly" target="_blank">Blazor wasm技術</a>實做<br />
                完全在瀏覧器內執行C#計算<br />
                我不會將任何使用者資料傳回伺服器<br />
                我不會取得你的存檔
            </p>
            <hr />
        </div>

        <div>
            <h4>Q: 為何會頁面凍結?</h4>
            <p>
                <a href="https://docs.microsoft.com/zh-tw/aspnet/core/blazor/hosting-models?view=aspnetcore-5.0#blazor-webassembly" target="_blank">Blazor wasm是直接在UI thread上執行</a><br />
                故長運算中無法更新頁面<br />
                這是技術限制<br />
                <b>請由F12開啟DevTools</b>，我會將執行狀態輸出在console中
            </p>
            <hr />
        </div>

        <div>
            <h4>Q: 有沒有辦法減少運算時間?</h4>
            <p>
                遊戲內的運算效能，是在瀏覧器上執行時的數倍強。<br />
                請使用<a href="https://blog.maki0419.com/2020/06/koikatu-save-load-compression.html" target="_blank">插件</a>。
            </p>
            <hr />
        </div>

        <div>
            <h4>Q: 我該如何選擇要壓縮，或是解壓縮?</h4>
            <p>
                工具會自動判斷，將一般存檔壓縮；將壓縮檔解壓縮。
            </p>
            <hr />
        </div>

        <div class="alert-danger" style="font-size:x-large"><a href="https://blog.maki0419.com/2020/06/koikatu-save-load-compression.html" target="_blank">壓縮存檔必須使用插件才能讀取</a></div>
    </div>
</div>

@code{
    private byte[] buffer = { };
    private long inputFileSize = 0;
    private string filename = "";
    private bool loading = false;
    private bool doCompare = true;
    private int startTime = 0;
    private bool compress = true;

    public Index() {
        Extension.Logger.logger = logger;
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            await JS.InvokeVoidAsync("indexJs.noticeBoxInit");
        }
    }

    private async void OnSelectedFile(InputFileChangeEventArgs e) {
        if (!await JS.InvokeAsync<bool>("confirm", "The browser page will be completely frozen during execution. Do you want to continue?")) return;

        long newSize;
        startTime = Convert.ToInt32(DateTime.UtcNow.AddHours(8).Subtract(new DateTime(1970, 1, 1)).TotalSeconds);
        using (MemoryStream inputStream = new MemoryStream())
        using (MemoryStream writeStream = new MemoryStream()) {
            loading = true;
            buffer = null;
            base.StateHasChanged();

            await e.File.OpenReadStream(524288000).CopyToAsync(inputStream);
            filename = e.File.Name.Replace(".png", "");
            inputFileSize = inputStream.Length;
            logger.LogDebug("Input file length: {size}", inputStream.Length);

            byte[] pngData = { };
            inputStream.Seek(0, SeekOrigin.Begin);
            using (BinaryReader binaryReader = new BinaryReader(inputStream)) {
                pngData = Extension.ImageHelper.LoadPngBytes(binaryReader);
                var pngEndPosition = binaryReader.BaseStream.Position;
                string token = slc.GuessToken(binaryReader);
                logger.LogDebug("Detact token as {token}", token);

                inputStream.Seek(pngEndPosition, SeekOrigin.Begin);
                if (slc.GuessCompressed(binaryReader)) {
                    // Compressed, do decompressed
                    logger.LogInformation("Get compressed file. Start decompress.");
                    pngData = await MakeWatermarkPic(pngData, token, false);
                    logger.LogDebug("New pngData size: {size}", pngData.Length);
                    inputStream.Seek(0, SeekOrigin.Begin);
                    newSize = slc.Load(inputStream, writeStream,
                        token: token,
                        pngData: pngData,
                        decompressProgress: (pg) => {
                            logger.LogInformation("Decompress Progress: {pg:p3}", pg);
                        });
                    filename += "_decompressed.png";
                    compress = false;
                } else {
                    // Not compressed, do compress
                    logger.LogInformation("Get not compressed file. Start compress.");
                    pngData = await MakeWatermarkPic(pngData, token, true);
                    logger.LogDebug("New pngData size: {size}", pngData.Length);
                    inputStream.Seek(0, SeekOrigin.Begin);
                    newSize = slc.Save(inputStream, writeStream,
                        token: token,
                        pngData: pngData,
                        compressProgress: (pg) => {
                            logger.LogInformation("Compress Progress: {pg:p3}", pg);
                        },
                        doComapre: doCompare,
                        compareProgress: (pg) => {
                            logger.LogInformation("Compare Progress: {pg:p3}", pg);
                        });
                    filename += "_compressed.png";
                    compress = true;
                }
            }
            buffer = writeStream.ToArray();
            logger.LogDebug("Output file length: {size}", newSize);
            loading = false;
            base.StateHasChanged();
        }
    }

    private async Task<byte[]> MakeWatermarkPic(byte[] pngData, string token, bool zip) {
        string background_base64URI = $"data:image;base64,{System.Convert.ToBase64String(pngData)}";
        var watermark = new byte[] { };
        if (zip) {
            watermark = Extension.ImageHelper.LoadDllResourceToBytes($"KK_SaveLoadCompression.Resources.zip_watermark.png");
        } else {
            watermark = Extension.ImageHelper.LoadDllResourceToBytes($"KK_SaveLoadCompression.Resources.unzip_watermark.png");
        }
        string watermark_base64URI = $"data:image;base64,{System.Convert.ToBase64String(watermark)}";

        double scale = (double)(slc.GetScaleTimes(token) * Extension.ImageHelper.GetDimensions(pngData)[0]) / Extension.ImageHelper.GetDimensions(watermark)[0];
        logger.LogDebug("Png width: {widthBack} : {widthWater}", Extension.ImageHelper.GetDimensions(pngData)[0], Extension.ImageHelper.GetDimensions(watermark)[0]);
        logger.LogDebug("Watermark Scale : {scale}", scale);

        var base64 = await JS.InvokeAsync<string>("indexJs.addWatermark", background_base64URI, watermark_base64URI, scale);
        return System.Convert.FromBase64String(base64);
    }

    private async void DownloadFile() {
        logger.LogInformation("Start download: {filename}", filename);
        logger.LogDebug("File size: {filesize}", buffer.Length);
        loading = true;
        base.StateHasChanged();
        await Task.Yield();

        await BlazorDownloadFileService.AddBuffer(buffer);
        await BlazorDownloadFileService.DownloadBinaryBuffers(filename);

        await BlazorDownloadFileService.ClearBuffers();

        loading = false;
        base.StateHasChanged();
    }
}

