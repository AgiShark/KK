@page "/"
@using System.IO;
@using Microsoft.Extensions.Logging
@using Token = KK_SaveLoadCompression.SaveLoadCompression.Token;
@inject KK_SaveLoadCompression.SaveLoadCompression slc;
@inject IJSRuntime JS;
@inject ILogger<Index> logger;
@inject BlazorDownloadFile.IBlazorDownloadFileService BlazorDownloadFileService;

<InputFile OnChange="@OnSelectedFile" AllowedExtensions=".png;"></InputFile>
<br />

@if (loading) {
    <div class="lds-dual-ring"></div>
}

@if (null != buffer && buffer.Length > 0) {
    <img src="data:image;base64,@System.Convert.ToBase64String(buffer)" />
    <p>
        @*Compression finish in {Time.time - startTime:n2} seconds<br />*@
        Size compress from @inputFileSize bytes to @buffer.Length bytes<br />
        Compress ratio: @($"{Convert.ToDecimal(inputFileSize) / buffer.Length:n3}")/1, which means it is now @($"{Convert.ToDecimal(buffer.Length) / inputFileSize:p3}") big.
        <button @onclick=@(async () => await BlazorDownloadFileService.DownloadFile(filename+"_compressed.png", buffer, "application/octet-stream"))>Dowload</button>
    </p>
}

@code{
    private byte[] buffer = { };
    private long inputFileSize = 0;
    private string filename = "";
    private bool loading = false;

    public Index() {
        Extension.Logger.logger = logger;
    }

    private async void OnSelectedFile(InputFileChangeEventArgs e) {
        //Extension.Logger.logger = logger;
        logger.LogDebug(e.File.Name);
        long newSize;
        using (MemoryStream inputStream = new MemoryStream())
        using (MemoryStream writeStream = new MemoryStream()) {
            loading = true;
            buffer = null;
            base.StateHasChanged();

            await e.File.OpenReadStream(524288000).CopyToAsync(inputStream);
            filename = e.File.Name.Replace(".png", "");
            inputFileSize = inputStream.Length;
            logger.LogDebug("Input file length: {size}", inputStream.Length);

            byte[] pngData = { };
            inputStream.Seek(0, SeekOrigin.Begin);
            using (BinaryReader binaryReader = new BinaryReader(inputStream)) {
                pngData = Extension.ImageHelper.LoadPngBytes(binaryReader);
                string token = slc.GuessToken(binaryReader);
                pngData = await MakeWatermarkPic(pngData, token);
                logger.LogDebug("New pngData size: {size}", pngData.Length);
                inputStream.Seek(0, SeekOrigin.Begin);
                newSize = slc.Save(inputStream, writeStream,
                    token: token,
                    pngData: pngData,
                    compressProgress: (pg) => {
                        logger.LogDebug("Compress Progress: {pg:p3}", pg);
                    },
                    compareProgress: (pg) => {
                        logger.LogDebug("Compare Progress: {pg:p3}", pg);
                    });
            }
            buffer = writeStream.ToArray();
            logger.LogDebug("Output file length: {size}", newSize);
            loading = false;
            base.StateHasChanged();
        }
    }

    private async Task<byte[]> MakeWatermarkPic(byte[] pngData, string token) {
        string background_base64URI = $"data:image;base64,{System.Convert.ToBase64String(pngData)}";
        var watermark = Extension.ImageHelper.LoadDllResourceToBytes($"KK_SaveLoadCompression.Resources.zip_watermark.png");
        string watermark_base64URI = $"data:image;base64,{System.Convert.ToBase64String(watermark)}";
        double scale = (double)(slc.GetScaleTimes(token) * Extension.ImageHelper.GetDimensions(pngData)[0]) / Extension.ImageHelper.GetDimensions(watermark)[0];
        logger.LogDebug("Png width: {widthBack} : {widthWater}", Extension.ImageHelper.GetDimensions(pngData)[0], Extension.ImageHelper.GetDimensions(watermark)[0]);
        logger.LogDebug("Watermark Scale : {scale}", scale);
        var base64 = await JS.InvokeAsync<string>("indexJs.addWatermark", background_base64URI, watermark_base64URI, scale);
        return System.Convert.FromBase64String(base64);
    }
}

