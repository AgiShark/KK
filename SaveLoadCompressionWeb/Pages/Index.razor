@page "/"
@using System.IO;
@using Microsoft.Extensions.Logging
@inject KK_SaveLoadCompression.SaveLoadCompression slc;
@inject IJSRuntime JS;
@inject ILogger<Index> logger;
@inject BlazorDownloadFile.IBlazorDownloadFileService BlazorDownloadFileService;

<p class="lead">
    @if (loading) {
        <div class="lds-dual-ring"></div>
    }
    <EditForm Model="this" @bind-hidden="loading">
        <label style="display: flex; text-align: center; ">
            <span class="btn btn-lg btn-outline-secondary" style="color:white;font-size: xx-large; display: flex; align-items: center; margin: auto; ">Choose your Koikatu png</span>
            <InputFile OnChange="@OnSelectedFile" accept="image/png" hidden></InputFile>
        </label>
        <br />
        <label data-toggle="tooltip" title="Skip the compare can reduce the computing time on compressing, but please bear the risk."> <InputCheckbox @bind-Value="@doCompare"></InputCheckbox>Do Compare</label>
    </EditForm>
</p>
@if (null != buffer && buffer.Length > 0) {
    <img src="data:image;base64,@System.Convert.ToBase64String(buffer)" style="max-height:50vh"/>
    <p class="lead">
        @if (compress) {
            @:Compression
        } else {
            @:Decompression
        } is complete.
        The processing is completed within @(Convert.ToInt32(DateTime.UtcNow.AddHours(8).Subtract(new DateTime(1970, 1, 1)).TotalSeconds) - startTime) seconds.<br />
        Size from @($"{(Convert.ToDecimal(inputFileSize) / 1048576):n2} MB to {(Convert.ToDecimal(buffer.Length) / 1048576):n2} MB.")<br />
        It is now @($"{Convert.ToDecimal(buffer.Length) / inputFileSize:p3}") big.<br />
        <a @onclick=@(async () => await BlazorDownloadFileService.DownloadFile(filename, buffer, "application/octet-stream")) class="btn btn-lg btn-outline-secondary">Save</a>
    </p>
}

@code{
    private byte[] buffer = { };
    private long inputFileSize = 0;
    private string filename = "";
    private bool loading = false;
    private bool doCompare = true;
    private int startTime = 0;
    private bool compress = true;

    public Index() {
        Extension.Logger.logger = logger;
    }

    private async void OnSelectedFile(InputFileChangeEventArgs e) {
        if (!await JS.InvokeAsync<bool>("confirm", "The browser page will be completely frozen during execution. Do you want to continue?")) return;

        long newSize;
        startTime = Convert.ToInt32(DateTime.UtcNow.AddHours(8).Subtract(new DateTime(1970, 1, 1)).TotalSeconds);
        using (MemoryStream inputStream = new MemoryStream())
        using (MemoryStream writeStream = new MemoryStream()) {
            loading = true;
            buffer = null;
            base.StateHasChanged();

            await e.File.OpenReadStream(524288000).CopyToAsync(inputStream);
            filename = e.File.Name.Replace(".png", "");
            inputFileSize = inputStream.Length;
            logger.LogDebug("Input file length: {size}", inputStream.Length);

            byte[] pngData = { };
            inputStream.Seek(0, SeekOrigin.Begin);
            using (BinaryReader binaryReader = new BinaryReader(inputStream)) {
                pngData = Extension.ImageHelper.LoadPngBytes(binaryReader);
                var pngEndPosition = binaryReader.BaseStream.Position;
                string token = slc.GuessToken(binaryReader);
                logger.LogDebug("Detact token as {token}", token);

                inputStream.Seek(pngEndPosition, SeekOrigin.Begin);
                if (slc.GuessCompressed(binaryReader)) {
                    // Compressed, do decompressed
                    logger.LogDebug("Get compressed file. Start decompress.");
                    inputStream.Seek(0, SeekOrigin.Begin);
                    newSize = slc.Load(inputStream, writeStream,
                        token: token,
                        decompressProgress: (pg) => {
                            logger.LogDebug("Decompress Progress: {pg:p3}", pg);
                        });
                    filename += "_decompressed.png";
                    compress = false;
                } else {
                    // Not compressed, do compress
                    logger.LogDebug("Get not compressed file. Start compress.");
                    pngData = await MakeWatermarkPic(pngData, token);
                    logger.LogDebug("New pngData size: {size}", pngData.Length);
                    inputStream.Seek(0, SeekOrigin.Begin);
                    newSize = slc.Save(inputStream, writeStream,
                        token: token,
                        pngData: pngData,
                        compressProgress: (pg) => {
                            logger.LogDebug("Compress Progress: {pg:p3}", pg);
                        },
                        doComapre: doCompare,
                        compareProgress: (pg) => {
                            logger.LogDebug("Compare Progress: {pg:p3}", pg);
                        });
                    filename += "_compressed.png";
                    compress = true; 
                }
            }
            buffer = writeStream.ToArray();
            logger.LogDebug("Output file length: {size}", newSize);
            loading = false;
            base.StateHasChanged();
        }
    }

    private async Task<byte[]> MakeWatermarkPic(byte[] pngData, string token) {
        string background_base64URI = $"data:image;base64,{System.Convert.ToBase64String(pngData)}";
        var watermark = Extension.ImageHelper.LoadDllResourceToBytes($"KK_SaveLoadCompression.Resources.zip_watermark.png");
        string watermark_base64URI = $"data:image;base64,{System.Convert.ToBase64String(watermark)}";

        double scale = (double)(slc.GetScaleTimes(token) * Extension.ImageHelper.GetDimensions(pngData)[0]) / Extension.ImageHelper.GetDimensions(watermark)[0];
        logger.LogDebug("Png width: {widthBack} : {widthWater}", Extension.ImageHelper.GetDimensions(pngData)[0], Extension.ImageHelper.GetDimensions(watermark)[0]);
        logger.LogDebug("Watermark Scale : {scale}", scale);

        var base64 = await JS.InvokeAsync<string>("indexJs.addWatermark", background_base64URI, watermark_base64URI, scale);
        return System.Convert.FromBase64String(base64);
    }
}

